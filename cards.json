[
    {
        "category": "C++ Move Semantics",
        "title": "Что такое lvalue и rvalue",
        "theory": "В C++ каждое выражение имеет категорию значения. lvalue (left value) — это объект, у которого есть постоянный адрес в памяти, можно взять &obj. rvalue (right value) — это временное значение, которое живёт только в момент выполнения выражения. Представь: lvalue — это переменная с именем, rvalue — это результат вычисления, который тут же исчезнет.",
        "code": "int x = 42;        // x — это lvalue (можем взять &x)\nint* ptr = &x;     // OK: у lvalue есть адрес\n\nint y = x + 5;     // (x + 5) — это rvalue\n// int* bad = &(x + 5);  // ОШИБКА: у rvalue нет адреса\n\n// Функция возвращает rvalue\nint getValue() { return 10; }\nint z = getValue(); // getValue() — rvalue"
    },
    {
        "category": "C++ Move Semantics",
        "title": "Зачем нужны rvalue references",
        "theory": "rvalue reference (тип&&) позволяет \"поймать\" временный объект и переиспользовать его ресурсы вместо копирования. Это как забрать чемодан у человека, который всё равно уезжает и ему он больше не нужен, вместо того чтобы покупать новый и перекладывать вещи. Синтаксис: Type&& — двойной амперсанд означает rvalue reference.",
        "code": "void process(std::string& s) {     // lvalue reference\n    std::cout << \"Processing lvalue\\n\";\n}\n\nvoid process(std::string&& s) {    // rvalue reference\n    std::cout << \"Processing rvalue\\n\";\n}\n\nstd::string name = \"Alice\";\nprocess(name);              // Вызов lvalue версии\nprocess(\"Bob\");             // Вызов rvalue версии\nprocess(std::string(\"Charlie\")); // rvalue версия"
    },
    {
        "category": "C++ Move Semantics",
        "title": "Move constructor",
        "theory": "Move constructor переносит ресурсы из временного объекта в новый объект вместо копирования. Это критично для производительности при работе с большими данными. После переноса старый объект остаётся в валидном, но \"опустошённом\" состоянии. В играх это экономит миллисекунды при передаче больших массивов вершин или текстур.",
        "code": "class Texture {\n    unsigned char* data;\n    size_t size;\npublic:\n    // Move constructor\n    Texture(Texture&& other) noexcept \n        : data(other.data), size(other.size) {\n        \n        other.data = nullptr;  // Забрали ресурсы\n        other.size = 0;        // Опустошили источник\n    }\n    \n    ~Texture() { \n        delete[] data;  // Безопасно: nullptr можно удалять\n    }\n};"
    },
    {
        "category": "C++ Move Semantics",
        "title": "std::move в деталях",
        "theory": "std::move не перемещает ничего сам по себе! Он только преобразует lvalue в rvalue, давая компилятору понять: \"этот объект можно безопасно разграбить\". Реальное перемещение происходит в move constructor или move assignment operator. После std::move оригинальный объект лучше не использовать, кроме как для присваивания или уничтожения.",
        "code": "std::vector<int> createBigVector() {\n    std::vector<int> temp(1000000);\n    // ... заполнение данными\n    return temp;  // Автоматический move (NRVO)\n}\n\nstd::vector<int> v1 = {1, 2, 3, 4, 5};\nstd::vector<int> v2 = std::move(v1);  // v1 теперь пуст\n\n// v1.size();  // OK, но вернёт 0\n// v1[0];      // Опасно! Неопределённое поведение\nv1 = {6, 7};   // OK: переприсваивание"
    },
    {
        "category": "C++ Move Semantics",
        "title": "Move assignment operator",
        "theory": "Move assignment переносит ресурсы при присваивании (operator=). Важно: нужно сначала очистить свои ресурсы, потом забрать чужие. Проверка на самоприсваивание (this != &other) критична, иначе можно удалить данные до того, как их переместить. Используется везде в STL контейнерах.",
        "code": "class Buffer {\n    int* data;\n    size_t capacity;\npublic:\n    // Move assignment\n    Buffer& operator=(Buffer&& other) noexcept {\n        if (this != &other) {          // Защита от самоприсваивания\n            delete[] data;             // Освобождаем свои ресурсы\n            \n            data = other.data;         // Забираем чужие\n            capacity = other.capacity;\n            \n            other.data = nullptr;      // Обнуляем источник\n            other.capacity = 0;\n        }\n        return *this;\n    }\n};"
    },
    {
        "category": "C++ Move Semantics",
        "title": "Perfect Forwarding",
        "theory": "Perfect forwarding позволяет передать аргументы в другую функцию ровно так, как они были переданы: lvalue как lvalue, rvalue как rvalue. Используется forwarding reference (T&&) в шаблонах и std::forward. Это основа для эффективных wrapper-функций и фабрик объектов в game engines.",
        "code": "// Без perfect forwarding (неэффективно)\nvoid wrapperBad(std::string s) {\n    process(s);  // Всегда копирование\n}\n\n// С perfect forwarding\ntemplate<typename T>\nvoid wrapperGood(T&& arg) {\n    process(std::forward<T>(arg));  // Сохраняет категорию\n}\n\nstd::string name = \"Alice\";\nwrapperGood(name);        // Передаёт как lvalue\nwrapperGood(\"Bob\");       // Передаёт как rvalue (эффективно)"
    },
    {
        "category": "C++ Smart Pointers",
        "title": "unique_ptr: основы",
        "theory": "unique_ptr — это умный указатель с эксклюзивным владением. Только один unique_ptr может владеть объектом. При уничтожении указателя автоматически вызывается delete. Копировать нельзя, только перемещать через std::move. Это zero-overhead абстракция: работает так же быстро, как обычный указатель, но безопаснее.",
        "code": "// Создание через make_unique (C++14, предпочтительно)\nauto player = std::make_unique<Player>(\"Hero\", 100);\n\n// Доступ к методам\nplayer->takeDamage(20);\nstd::cout << player->getHealth();  // 80\n\n// Проверка на nullptr\nif (player) {\n    player->heal(10);\n}\n\n// Автоматическое удаление при выходе из scope\n// delete player; — не нужно!"
    },
    {
        "category": "C++ Smart Pointers",
        "title": "unique_ptr: передача владения",
        "theory": "Передача владения unique_ptr означает, что один объект отдаёт указатель другому. После std::move оригинальный unique_ptr становится nullptr. Это гарантирует, что только один владелец существует в любой момент времени. В играх так передают ownership объектов между системами (например, из inventory в world).",
        "code": "std::unique_ptr<Weapon> createWeapon() {\n    auto sword = std::make_unique<Weapon>(\"Excalibur\");\n    return sword;  // Автоматический move\n}\n\nvoid equipWeapon(std::unique_ptr<Weapon> weapon) {\n    // Функция теперь владеет weapon\n}\n\nauto weapon = createWeapon();\nequipWeapon(std::move(weapon));  // Передали владение\n// weapon теперь nullptr, использовать нельзя!"
    },
    {
        "category": "C++ Smart Pointers",
        "title": "unique_ptr с массивами",
        "theory": "unique_ptr может управлять динамическими массивами через специализацию unique_ptr<T[]>. Автоматически вызывает delete[] вместо delete. Но обычно лучше использовать std::vector, который даёт больше функциональности и безопасности. unique_ptr<T[]> нужен для C-style API или низкоуровневой работы.",
        "code": "// Управление массивом\nauto vertices = std::make_unique<float[]>(1000);\nvertices[0] = 1.0f;\nvertices[1] = 2.0f;\n\n// Лучше использовать vector\nstd::vector<float> verticesBetter(1000);\nverticesBetter[0] = 1.0f;\n\n// Но unique_ptr<T[]> полезен для C API\nvoid legacyFunction(float* data, size_t size);\nlegacyFunction(vertices.get(), 1000);"
    },
    {
        "category": "C++ Smart Pointers",
        "title": "shared_ptr: основы",
        "theory": "shared_ptr позволяет нескольким указателям владеть одним объектом. Внутри хранит счётчик ссылок (reference count). Когда последний shared_ptr уничтожается, объект удаляется. Используй когда владение неоднозначно: например, несколько систем используют один ресурс (текстура, звук).",
        "code": "// Создание через make_shared (эффективнее)\nauto texture = std::make_shared<Texture>(\"hero.png\");\n\n// Несколько владельцев\nauto reference1 = texture;  // ref count = 2\nauto reference2 = texture;  // ref count = 3\n\nstd::cout << texture.use_count();  // 3\n\nreference1.reset();  // ref count = 2\nreference2.reset();  // ref count = 1\n// Когда texture выйдет из scope, объект удалится"
    },
    {
        "category": "C++ Smart Pointers",
        "title": "shared_ptr: циклические ссылки",
        "theory": "Опасность shared_ptr: циклические ссылки создают memory leak. Если объект A хранит shared_ptr на B, а B хранит shared_ptr на A, счётчики никогда не обнулятся. Решение: использовать weak_ptr для одной из связей. В играх это частая проблема в системах родитель-ребёнок (parent-child).",
        "code": "struct Node {\n    std::shared_ptr<Node> next;  // Проблема!\n    ~Node() { std::cout << \"Deleted\\n\"; }\n};\n\nauto node1 = std::make_shared<Node>();\nauto node2 = std::make_shared<Node>();\nnode1->next = node2;  // node2 ref count = 2\nnode2->next = node1;  // node1 ref count = 2\n\n// При выходе из scope:\n// node1 и node2 обнуляются, но объекты остаются!\n// ref count обоих = 1, деструкторы не вызываются"
    },
    {
        "category": "C++ Smart Pointers",
        "title": "weak_ptr: разрыв циклов",
        "theory": "weak_ptr — это \"слабая\" ссылка на объект, управляемый shared_ptr. Не увеличивает счётчик ссылок, поэтому не мешает удалению. Перед использованием нужно проверить, жив ли объект через lock(), который вернёт shared_ptr или nullptr. Идеален для связей child->parent или для кэшей.",
        "code": "struct Node {\n    std::shared_ptr<Node> next;\n    std::weak_ptr<Node> prev;  // Слабая ссылка!\n    ~Node() { std::cout << \"Deleted\\n\"; }\n};\n\nauto node1 = std::make_shared<Node>();\nauto node2 = std::make_shared<Node>();\nnode1->next = node2;      // shared\nnode2->prev = node1;      // weak (не увеличивает count)\n\n// Использование weak_ptr\nif (auto parent = node2->prev.lock()) {\n    parent->doSomething();  // Объект жив\n}"
    },
    {
        "category": "C++ Smart Pointers",
        "title": "Когда использовать какой указатель",
        "theory": "unique_ptr — дефолтный выбор для владения. Используй когда владение чёткое и единственное. shared_ptr — когда несколько объектов разделяют владение и неясно, кто последний. weak_ptr — для наблюдения без владения, разрыва циклов. Сырой указатель (T*) — когда не владеешь объектом, только наблюдаешь (например, параметры функций).",
        "code": "class GameObject {\n    std::unique_ptr<Mesh> mesh;      // Владеет эксклюзивно\n    std::shared_ptr<Texture> tex;    // Разделяется с другими\n    std::weak_ptr<GameObject> target; // Наблюдает цель\n    GameObject* parent;               // Не владеет (вверх по иерархии)\n    \npublic:\n    void update(float dt) {\n        if (auto targetObj = target.lock()) {\n            // Цель жива, можем использовать\n        }\n    }\n};"
    },
    {
        "category": "C++ Lambda",
        "title": "Синтаксис lambda функций",
        "theory": "Lambda — это анонимная функция, которую можно создать прямо в месте использования. Синтаксис: [capture](parameters) -> return_type { body }. Capture список определяет, какие переменные из внешней области видимости доступны. Return type можно опустить, компилятор выведет сам. Это как создать мини-функцию на лету.",
        "code": "// Простейшая lambda\nauto add = [](int a, int b) { return a + b; };\nstd::cout << add(5, 3);  // 8\n\n// С явным return type\nauto divide = [](int a, int b) -> double {\n    return static_cast<double>(a) / b;\n};\n\n// Используется сразу\nint result = [](int x) { return x * x; }(5);  // 25"
    },
    {
        "category": "C++ Lambda",
        "title": "Захват переменных (capture)",
        "theory": "Capture список [...]  определяет доступ к внешним переменным. [=] захватывает всё по значению (копия), [&] — всё по ссылке, [x, &y] — x по значению, y по ссылке. [this] захватывает this pointer класса. Захват по значению безопасен, но создаёт копии. Захват по ссылке эффективен, но опасен если lambda переживёт переменную.",
        "code": "int multiplier = 10;\nint offset = 5;\n\n// Захват по значению\nauto byValue = [=](int x) { return x * multiplier + offset; };\n\n// Захват по ссылке\nauto byRef = [&](int x) { \n    offset++;  // Можем модифицировать\n    return x * multiplier; \n};\n\n// Смешанный захват\nauto mixed = [multiplier, &offset](int x) {\n    return x * multiplier + (offset++);\n};"
    },
    {
        "category": "C++ Lambda",
        "title": "Mutable lambda",
        "theory": "По умолчанию lambda захватывающая по значению не может модифицировать копии. Ключевое слово mutable разрешает изменять захваченные копии (но не оригиналы!). Это полезно когда lambda должна хранить состояние между вызовами, как мини-объект. В играх используется для счётчиков, аккумуляторов в алгоритмах.",
        "code": "int counter = 0;\n\n// Без mutable — ошибка компиляции\n// auto bad = [counter]() { counter++; };  // ОШИБКА\n\n// С mutable — OK\nauto countCalls = [counter]() mutable {\n    return ++counter;  // Изменяем КОПИЮ\n};\n\nstd::cout << countCalls();  // 1\nstd::cout << countCalls();  // 2\nstd::cout << counter;       // 0 (оригинал не изменился!)"
    },
    {
        "category": "C++ Lambda",
        "title": "Lambda в STL алгоритмах",
        "theory": "Lambda идеально подходят для STL алгоритмов как предикаты и операции. Можно написать кастомную логику прямо на месте вместо создания отдельной функции. Компилятор оптимизирует lambda так же хорошо, как обычные функции. В геймдеве это стандарт для сортировки, фильтрации, трансформации данных.",
        "code": "std::vector<int> scores = {85, 92, 78, 95, 88};\n\n// Сортировка по убыванию\nstd::sort(scores.begin(), scores.end(), \n    [](int a, int b) { return a > b; });\n\n// Подсчёт высоких баллов\nint highScores = std::count_if(scores.begin(), scores.end(),\n    [](int score) { return score >= 90; });\n\n// Умножение всех на 2\nstd::transform(scores.begin(), scores.end(), scores.begin(),\n    [](int s) { return s * 2; });"
    },
    {
        "category": "C++ Lambda",
        "title": "Generic lambda (C++14)",
        "theory": "Generic lambda использует auto в параметрах, работая как шаблонная функция. Компилятор создаёт отдельную версию для каждого типа. Это удобно когда логика одинакова для разных типов. Экономит код и делает lambda более гибкими. В C++20 можно даже использовать template<typename T>.",
        "code": "// Generic lambda\nauto print = [](const auto& item) {\n    std::cout << item << std::endl;\n};\n\nprint(42);           // int\nprint(3.14);         // double\nprint(\"Hello\");     // const char*\n\n// С несколькими параметрами\nauto multiply = [](auto a, auto b) { return a * b; };\nstd::cout << multiply(5, 10);      // 50\nstd::cout << multiply(2.5, 4.0);   // 10.0"
    },
    {
        "category": "C++ Type Inference",
        "title": "Auto: основы",
        "theory": "Ключевое слово auto заставляет компилятор автоматически вывести тип переменной из инициализатора. Уменьшает шаблонный код, особенно с длинными типами итераторов или вложенными шаблонами. Код становится чище, но тип должен быть очевиден из контекста. Переменная с auto ОБЯЗАНА быть инициализирована.",
        "code": "// Вместо длинного типа\nstd::vector<std::string>::iterator it = vec.begin();\nauto it2 = vec.begin();  // Проще и понятнее!\n\n// С сложными типами\nstd::map<std::string, std::vector<int>> data;\nauto pair = data.insert({\"key\", {1, 2, 3}});\n\n// auto ДОЛЖНА быть инициализирована\n// auto x;  // ОШИБКА: не можем вывести тип\nauto y = 42;  // OK: int"
    },
    {
        "category": "C++ Type Inference",
        "title": "Auto и ссылки",
        "theory": "auto по умолчанию отбрасывает ссылки и const. Чтобы сохранить ссылку, нужно явно написать auto& или const auto&. Это важно для избежания лишних копий. auto&& — это forwarding reference, принимает и lvalue и rvalue. В range-based for loops часто используют const auto& для эффективности.",
        "code": "std::vector<int> vec = {1, 2, 3, 4, 5};\n\n// auto делает КОПИЮ\nauto copy = vec[0];  // int, копия значения\ncopy = 100;          // vec[0] не изменился\n\n// auto& — ссылка, можем модифицировать\nauto& ref = vec[0];  // int&\nref = 100;           // vec[0] теперь 100!\n\n// const auto& — неизменяемая ссылка\nfor (const auto& item : vec) {  // Нет копирования\n    std::cout << item;\n}"
    },
    {
        "category": "C++ Type Inference",
        "title": "decltype: вывод типа выражения",
        "theory": "decltype выводит тип выражения, не вычисляя его. В отличие от auto, сохраняет ссылки и const. Используется когда нужен точный тип выражения, например, для возвращаемого типа функции или создания переменной того же типа. Полезно в шаблонах для метапрограммирования.",
        "code": "int x = 5;\nint& ref = x;\n\n// auto отбрасывает ссылку\nauto a = ref;        // int (не ссылка!)\n\n// decltype сохраняет точный тип\ndecltype(ref) b = x; // int& (ссылка)\n\n// Для сложных выражений\nstd::vector<int> vec;\ndecltype(vec[0]) elem = vec[0];  // int&\ndecltype(vec.size()) size = 10;   // size_t"
    },
    {
        "category": "C++ Type Inference",
        "title": "Trailing return type",
        "theory": "Trailing return type (auto func() -> ReturnType) позволяет указать возвращаемый тип после параметров. Это нужно когда тип зависит от параметров функции или использует decltype. С C++14 можно опускать -> и компилятор выведет тип из return. В шаблонах это стандарт для гибкости.",
        "code": "// Проблема: не можем использовать T и U до их объявления\n// decltype(a + b) add(T a, U b)  // ОШИБКА\n\n// Решение: trailing return type\ntemplate<typename T, typename U>\nauto add(T a, U b) -> decltype(a + b) {\n    return a + b;\n}\n\n// C++14: автовывод\ntemplate<typename T, typename U>\nauto multiply(T a, U b) {  // Тип выведется из return\n    return a * b;\n}"
    },
    {
        "category": "C++ Templates",
        "title": "Variadic templates: основы",
        "theory": "Variadic templates позволяют функции или классу принимать произвольное количество аргументов разных типов. Используется parameter pack (Args...). Разворачивается рекурсивно или через fold expressions (C++17). Это основа для std::tuple, std::function, printf-like функций. В играх — для event систем, generic logging.",
        "code": "// Базовый случай (остановка рекурсии)\nvoid print() {\n    std::cout << std::endl;\n}\n\n// Рекурсивный случай\ntemplate<typename T, typename... Args>\nvoid print(T first, Args... rest) {\n    std::cout << first << \" \";\n    print(rest...);  // Рекурсивный вызов с остальными\n}\n\nprint(1, 2.5, \"hello\", 'x');  // 1 2.5 hello x"
    },
    {
        "category": "C++ Templates",
        "title": "Fold expressions (C++17)",
        "theory": "Fold expressions упрощают работу с parameter packs, позволяя применить бинарную операцию ко всем аргументам. Синтаксис: (pack op ...) для правой свёртки, (... op pack) для левой. Поддерживает +, *, &&, ||, и другие операторы. Заменяет рекурсивные шаблоны на однострочники, код становится в разы проще.",
        "code": "// Сумма всех аргументов (любых типов)\ntemplate<typename... Args>\nauto sum(Args... args) {\n    return (args + ...);  // Fold expression!\n}\n\nstd::cout << sum(1, 2, 3, 4, 5);  // 15\nstd::cout << sum(1.5, 2.5, 3.0);  // 7.0\n\n// Вывод всех аргументов\ntemplate<typename... Args>\nvoid printAll(Args... args) {\n    (std::cout << ... << args) << '\\n';  // Fold\n}"
    },
    {
        "category": "C++ constexpr",
        "title": "constexpr функции",
        "theory": "constexpr означает \"может быть вычислено на этапе компиляции\". Если все аргументы — константы времени компиляции, функция выполняется компилятором, результат вшивается в код. Если аргументы runtime — работает как обычная функция. Это даёт zero-cost абстракции: удобство функций без overhead вызова.",
        "code": "constexpr int square(int x) {\n    return x * x;\n}\n\n// Вычисляется на этапе компиляции\nconstexpr int compile = square(5);  // = 25, в коде как литерал\nint arr[square(3)];  // Массив из 9 элементов\n\n// Может работать и в runtime\nint x;\nstd::cin >> x;\nint runtime = square(x);  // Обычный вызов функции"
    },
    {
        "category": "C++ constexpr",
        "title": "constexpr переменные",
        "theory": "constexpr переменная — это константа времени компиляции, которая ДОЛЖНА быть инициализирована constexpr выражением. Гарантирует вычисление в compile-time. Отличие от const: const может быть runtime значением, constexpr — только compile-time. В играх используется для размеров буферов, констант физики, magic numbers.",
        "code": "constexpr int MAX_PLAYERS = 64;  // Compile-time константа\nconstexpr float PI = 3.14159f;\nconstexpr int SIZE = MAX_PLAYERS * 2;  // OK: вычисляется\n\nint arr[MAX_PLAYERS];  // OK: размер известен\n\n// const vs constexpr\nint getUserInput();\nconst int a = getUserInput();      // OK: runtime const\n// constexpr int b = getUserInput(); // ОШИБКА: не constexpr\nconstexpr int c = 42;              // OK"
    },
    {
        "category": "C++ constexpr",
        "title": "constexpr и классы",
        "theory": "Конструктор класса может быть constexpr, что позволяет создавать объекты в compile-time. Все члены класса должны быть инициализированы, деструктор должен быть тривиальным. constexpr методы могут вызываться на constexpr объектах. Это мощный инструмент для создания compile-time вычисляемых структур данных.",
        "code": "class Vec2 {\n    float x, y;\npublic:\n    constexpr Vec2(float x_, float y_) : x(x_), y(y_) {}\n    \n    constexpr float length() const {\n        return std::sqrt(x*x + y*y);  // C++26: sqrt constexpr\n    }\n};\n\nconstexpr Vec2 pos(3.0f, 4.0f);\n// constexpr float len = pos.length();  // Будущее C++\nfloat len = pos.length();  // Пока runtime"
    },
    {
        "category": "C++ Modern Features",
        "title": "Range-based for loop",
        "theory": "Range-based for автоматически итерирует по контейнеру без итераторов. Синтаксис: for (auto elem : container). Работает с любым типом, у которого есть begin() и end(). Для избежания копий используй const auto&. Для модификации — auto&. Чище и безопаснее обычных циклов, не нужно следить за индексами.",
        "code": "std::vector<std::string> names = {\"Alice\", \"Bob\", \"Charlie\"};\n\n// Копирование (медленно для больших объектов)\nfor (auto name : names) {\n    std::cout << name;  // name — копия\n}\n\n// Ссылка (быстро, read-only)\nfor (const auto& name : names) {\n    std::cout << name;  // Без копирования\n}\n\n// Модификация\nfor (auto& name : names) {\n    name += \" Smith\";  // Изменяем оригинал\n}"
    },
    {
        "category": "C++ Modern Features",
        "title": "Structured bindings (C++17)",
        "theory": "Structured bindings позволяют распаковать tuple, pair, struct или array в отдельные переменные одной строкой. Синтаксис: auto [a, b, c] = tuple. Делает код с парами и кортежами намного читабельнее. Особенно полезно при итерации по std::map или возвращении нескольких значений из функции.",
        "code": "std::map<std::string, int> scores = {{\"Alice\", 95}, {\"Bob\", 87}};\n\n// Старый способ\nfor (const auto& pair : scores) {\n    std::cout << pair.first << \": \" << pair.second;\n}\n\n// Structured bindings (чище!)\nfor (const auto& [name, score] : scores) {\n    std::cout << name << \": \" << score;\n}\n\n// С функциями\nauto [min, max] = std::minmax({5, 2, 8, 1});\nstd::cout << min << \" \" << max;  // 1 8"
    },
    {
        "category": "C++ Modern Features",
        "title": "std::optional",
        "theory": "std::optional представляет значение, которое может отсутствовать. Альтернатива возврату nullptr или магического значения типа -1. Проверка через has_value() или оператор bool. Доступ к значению через value() (с проверкой) или оператор * (без проверки). В играх используется для опциональных компонентов, результатов поиска.",
        "code": "std::optional<int> findScore(const std::string& name) {\n    if (name == \"Alice\") return 95;\n    return std::nullopt;  // Значение отсутствует\n}\n\nauto score = findScore(\"Alice\");\nif (score) {  // Или score.has_value()\n    std::cout << \"Score: \" << *score;  // 95\n}\n\nint value = score.value_or(0);  // 95 или 0 если пусто\n// int bad = *score;  // Опасно если пусто!"
    },
    {
        "category": "C++ Modern Features",
        "title": "std::variant",
        "theory": "std::variant — это type-safe union, хранящий одно значение из нескольких типов. Всегда знает, какой тип сейчас хранится. Доступ через std::get<T> или std::visit. Занимает размер самого большого типа + overhead для индекса. Используется для полиморфизма без виртуальных функций, состояний state machine.",
        "code": "std::variant<int, float, std::string> data;\n\ndata = 42;            // Хранит int\ndata = 3.14f;         // Теперь хранит float\ndata = \"hello\";       // Теперь хранит string\n\n// Доступ с проверкой типа\nif (auto* str = std::get_if<std::string>(&data)) {\n    std::cout << *str;\n}\n\n// Visitor pattern\nstd::visit([](auto&& arg) { std::cout << arg; }, data);"
    },
    {
        "category": "C++ Modern Features",
        "title": "std::any",
        "theory": "std::any может хранить значение ЛЮБОГО типа. В отличие от variant, список типов не фиксирован. Использует type erasure и динамическое выделение памяти для больших объектов. Доступ через std::any_cast с указанием типа. Медленнее variant, используй когда тип действительно непредсказуем (например, generic property system).",
        "code": "std::any value;\n\nvalue = 42;                    // int\nvalue = std::string(\"text\");   // string\nvalue = 3.14;                  // double\n\n// Проверка и извлечение типа\nif (value.type() == typeid(std::string)) {\n    std::string str = std::any_cast<std::string>(value);\n    std::cout << str;\n}\n\n// std::any_cast бросает исключение если тип неверный\ntry {\n    int x = std::any_cast<int>(value);  // Исключение!\n} catch (const std::bad_any_cast&) {}"
    },
    {
        "category": "C++ Concepts",
        "title": "Что такое Concepts (C++20)",
        "theory": "Concepts — это именованные ограничения на типы шаблонов. Заменяют SFINAE более понятным синтаксисом. Компилятор проверяет требования до инстанцирования шаблона, давая понятные ошибки. Вместо \"template<typename T>\" можно написать \"template<Sortable T>\". В Unreal Engine 5 начинают активно использоваться.",
        "code": "// Старый способ (SFINAE)\ntemplate<typename T,\n    typename = std::enable_if_t<std::is_integral_v<T>>>\nT oldAdd(T a, T b) { return a + b; }\n\n// С Concepts (читабельно!)\ntemplate<std::integral T>\nT add(T a, T b) { return a + b; }\n\nadd(5, 10);      // OK: int\n// add(5.5, 1.0);  // ОШИБКА: double не integral"
    },
    {
        "category": "C++ Concepts",
        "title": "Создание своих Concepts",
        "theory": "Свой Concept создаётся через ключевое слово concept и requires. Определяет набор требований к типу: наличие методов, операторов, наследование. Можно комбинировать несколько требований через && и ||. Создаёт самодокументируемый код: название Concept объясняет, что от типа требуется.",
        "code": "// Требуем наличие методов draw() и update()\ntemplate<typename T>\nconcept Drawable = requires(T obj, float dt) {\n    { obj.draw() } -> std::same_as<void>;\n    { obj.update(dt) } -> std::same_as<void>;\n};\n\n// Используем в функции\ntemplate<Drawable T>\nvoid render(T& object, float deltaTime) {\n    object.update(deltaTime);\n    object.draw();\n}"
    },
    {
        "category": "C++ STL Containers",
        "title": "std::vector: внутреннее устройство",
        "theory": "Vector хранит элементы в непрерывном блоке памяти на куче. При достижении capacity происходит реаллокация: выделяется больший блок (обычно x1.5 или x2), элементы копируются/перемещаются, старый блок удаляется. Итераторы после реаллокации инвалидируются! reserve() предвыделяет память, избегая реаллокаций.",
        "code": "std::vector<int> vec;\nvec.reserve(100);  // Предвыделяем память для 100 элементов\n\nfor (int i = 0; i < 100; ++i) {\n    vec.push_back(i);  // Без реаллокаций!\n}\n\nstd::cout << vec.size();      // 100 элементов\nstd::cout << vec.capacity();  // 100 (или больше)\n\nvec.shrink_to_fit();  // Освобождаем лишнюю память"
    },
    {
        "category": "C++ STL Containers",
        "title": "std::vector: emplace_back vs push_back",
        "theory": "push_back принимает готовый объект и копирует/перемещает его в вектор. emplace_back конструирует объект прямо внутри вектора из аргументов, избегая лишнего copy/move. Для простых типов разницы нет, но для сложных объектов emplace_back эффективнее. В геймдеве критично для минимизации копирований больших структур.",
        "code": "struct Enemy {\n    std::string name;\n    int health;\n    Enemy(std::string n, int h) : name(n), health(h) {}\n};\n\nstd::vector<Enemy> enemies;\n\n// push_back: создаёт временный объект, потом перемещает\nenemies.push_back(Enemy(\"Goblin\", 50));  // 1 конструктор + 1 move\n\n// emplace_back: конструирует прямо в векторе\nenemies.emplace_back(\"Orc\", 100);  // 1 конструктор, без move!"
    },
    {
        "category": "C++ STL Containers",
        "title": "std::deque: когда использовать",
        "theory": "Deque (double-ended queue) позволяет быстро добавлять/удалять с обоих концов за O(1). Реализован как массив блоков, элементы не лежат непрерывно. Нет реаллокации как у vector, итераторы стабильнее. Чуть медленнее vector при последовательном доступе. Используй когда нужна очередь/стек с двух сторон, или stable iterators.",
        "code": "std::deque<int> dq;\n\n// Быстро с обоих концов\ndq.push_back(1);    // O(1)\ndq.push_front(2);   // O(1)\ndq.pop_back();      // O(1)\ndq.pop_front();     // O(1)\n\n// Случайный доступ чуть медленнее vector\nint val = dq[5];    // O(1), но с overhead\n\n// Итераторы не инвалидируются при push/pop с концов!\nauto it = dq.begin();\ndq.push_back(100);  // it всё ещё валиден!"
    },
    {
        "category": "C++ STL Containers",
        "title": "std::list: двусвязный список",
        "theory": "List — это двусвязный список, каждый элемент хранит указатели на следующий и предыдущий. Вставка/удаление в любом месте O(1) если есть итератор. Итераторы никогда не инвалидируются (кроме удалённых элементов). Минусы: медленный случайный доступ O(n), больше памяти на узел. Используй когда часто вставляешь/удаляешь в середине.",
        "code": "std::list<int> lst = {1, 2, 3, 4, 5};\n\n// Вставка в середину эффективна\nauto it = std::find(lst.begin(), lst.end(), 3);\nlst.insert(it, 99);  // O(1) с итератором\n\n// Удаление не инвалидирует другие итераторы\nauto it2 = lst.begin();\nlst.erase(it);  // Удаляем элемент\n// it2 всё ещё валиден!\n\n// Нет operator[]: медленный доступ\n// int x = lst[2];  // ОШИБКА!"
    },
    {
        "category": "C++ STL Containers",
        "title": "std::map: красно-чёрное дерево",
        "theory": "Map — это упорядоченный ассоциативный контейнер на основе сбалансированного дерева (обычно красно-чёрное). Элементы отсортированы по ключу. Операции search/insert/delete O(log n). Ключи уникальны, для дубликатов используй multimap. Требует оператор< для ключа или кастомный компаратор.",
        "code": "std::map<std::string, int> playerScores;\n\n// Вставка и доступ\nplayerScores[\"Alice\"] = 100;  // O(log n)\nplayerScores.insert({\"Bob\", 85});\n\n// Поиск\nauto it = playerScores.find(\"Alice\");  // O(log n)\nif (it != playerScores.end()) {\n    std::cout << it->second;  // 100\n}\n\n// Итерация в отсортированном порядке\nfor (const auto& [name, score] : playerScores) {\n    std::cout << name << \": \" << score;\n}"
    },
    {
        "category": "C++ STL Containers",
        "title": "std::unordered_map: хеш-таблица",
        "theory": "Unordered_map — это хеш-таблица с амортизированным O(1) для поиска/вставки/удаления. Элементы не упорядочены. Требует хеш-функцию для ключа (есть для стандартных типов). При коллизиях производительность падает до O(n). Используй когда не нужен порядок, но критична скорость. В играх — для быстрых lookup таблиц.",
        "code": "std::unordered_map<int, std::string> entities;\n\n// Быстрый доступ O(1) в среднем\nentities[1001] = \"Player\";\nentities[2042] = \"Enemy\";\n\n// Поиск\nif (entities.find(1001) != entities.end()) {  // O(1)\n    std::cout << \"Found!\";\n}\n\n// Можно настроить начальный размер\nentities.reserve(10000);  // Избегаем rehashing\n\n// Для своих типов нужна hash функция"
    },
    {
        "category": "C++ STL Containers",
        "title": "Кастомная хеш-функция",
        "theory": "Для использования своего типа в unordered_map/set нужно определить специализацию std::hash. Хеш-функция должна быть детерминированной и равномерно распределять значения. Можно комбинировать хеши полей через XOR и битовые сдвиги. Плохая хеш-функция приводит к коллизиям и деградации производительности до O(n).",
        "code": "struct Point {\n    int x, y;\n    bool operator==(const Point& other) const {\n        return x == other.x && y == other.y;\n    }\n};\n\n// Специализация std::hash\nnamespace std {\n    template<>\n    struct hash<Point> {\n        size_t operator()(const Point& p) const {\n            return hash<int>()(p.x) ^ (hash<int>()(p.y) << 1);\n        }\n    };\n}\n\nstd::unordered_map<Point, std::string> map;"
    },
    {
        "category": "C++ STL",
        "title": "std::string_view (C++17)",
        "theory": "string_view — это lightweight ссылка на строку без владения. Не копирует данные, хранит только указатель и размер. Эффективен для чтения строк без модификации. Опасность: не владеет данными, если оригинальная строка удалена — dangling reference. Используй для параметров функций вместо const string&.",
        "code": "void printString(std::string_view sv) {  // Нет копирования!\n    std::cout << sv;\n}\n\nstd::string str = \"Hello, World!\";\nconst char* cstr = \"C-style string\";\n\nprintString(str);              // OK\nprintString(cstr);             // OK\nprintString(\"literal\");        // OK\nprintString(str.substr(0, 5)); // OK: \"Hello\"\n\n// Опасность: dangling reference\nstd::string_view getDangling() {\n    std::string temp = \"bad\";\n    return temp;  // temp удаляется, view невалиден!\n}"
    },
    {
        "category": "C++ STL Algorithms",
        "title": "std::sort и компараторы",
        "theory": "std::sort использует интроспективную сортировку (гибрид quicksort, heapsort, insertion sort) со сложностью O(n log n). По умолчанию сортирует по operator<. Можно передать кастомный компаратор как функцию или lambda. Компаратор должен быть strict weak ordering: антирефлексивен, транзитивен. Неправильный компаратор даёт undefined behavior.",
        "code": "std::vector<int> nums = {5, 2, 8, 1, 9};\n\n// По возрастанию (default)\nstd::sort(nums.begin(), nums.end());\n\n// По убыванию\nstd::sort(nums.begin(), nums.end(), std::greater<int>());\n\n// Кастомный компаратор\nstruct Player { std::string name; int score; };\nstd::vector<Player> players = {{\"Alice\", 95}, {\"Bob\", 87}};\n\nstd::sort(players.begin(), players.end(),\n    [](const Player& a, const Player& b) {\n        return a.score > b.score;  // По убыванию score\n    });"
    },
    {
        "category": "C++ STL Algorithms",
        "title": "Binary search алгоритмы",
        "theory": "Binary search алгоритмы работают только на ОТСОРТИРОВАННЫХ диапазонах. std::binary_search возвращает bool. std::lower_bound находит первый элемент >= значения. std::upper_bound находит первый > значения. Все O(log n). Критично: данные должны быть отсортированы, иначе результат неопределён.",
        "code": "std::vector<int> sorted = {1, 3, 5, 7, 9, 11};\n\n// Поиск элемента\nbool found = std::binary_search(sorted.begin(), sorted.end(), 5);\n\n// Позиция для вставки с сохранением сортировки\nauto it = std::lower_bound(sorted.begin(), sorted.end(), 6);\n// it указывает на 7 (первый >= 6)\n\nauto it2 = std::upper_bound(sorted.begin(), sorted.end(), 5);\n// it2 указывает на 7 (первый > 5)\n\nsorted.insert(it, 6);  // Вставка с сохранением порядка"
    },
    {
        "category": "C++ STL Algorithms",
        "title": "std::transform",
        "theory": "std::transform применяет функцию к каждому элементу диапазона, записывая результат в другой (или тот же) диапазон. Может комбинировать два диапазона. Не изменяет размер контейнера, только значения. Эффективнее ручного цикла благодаря оптимизациям компилятора. Идеален для применения операции ко всем элементам.",
        "code": "std::vector<int> numbers = {1, 2, 3, 4, 5};\nstd::vector<int> squares(numbers.size());\n\n// Возведение в квадрат\nstd::transform(numbers.begin(), numbers.end(),\n               squares.begin(),\n               [](int x) { return x * x; });\n// squares = {1, 4, 9, 16, 25}\n\n// Комбинирование двух диапазонов\nstd::vector<int> other = {10, 20, 30, 40, 50};\nstd::transform(numbers.begin(), numbers.end(),\n               other.begin(), numbers.begin(),\n               std::plus<>());  // numbers += other"
    },
    {
        "category": "C++ Memory Management",
        "title": "Stack vs Heap",
        "theory": "Stack — автоматическая память, выделяется/освобождается при входе/выходе из scope. Быстрая (просто сдвиг указателя стека), ограниченный размер (~1-8 МБ). Heap — динамическая память, выделяется через new/malloc, освобождается delete/free. Медленнее (системный вызов), но размер ограничен только RAM. В играх критично минимизировать heap allocations в горячих путях.",
        "code": "void function() {\n    // Stack allocation (быстро)\n    int stackVar = 42;          // ~1 наносекунда\n    int stackArray[100];        // Тоже stack\n    \n    // Heap allocation (медленно)\n    int* heapVar = new int(42); // ~100+ наносекунд\n    int* heapArray = new int[100];\n    \n    delete heapVar;\n    delete[] heapArray;\n    \n    // stackVar и stackArray удаляются автоматически\n}"
    },
    {
        "category": "C++ Memory Management",
        "title": "RAII: Resource Acquisition Is Initialization",
        "theory": "RAII — это паттерн C++: ресурс получается в конструкторе, освобождается в деструкторе. Гарантирует освобождение даже при исключениях или early return. Это основа умных указателей, lock_guard, fstream. В C++ нет garbage collector, вместо этого — детерминированное освобождение через RAII. Это делает C++ предсказуемым для realtime систем.",
        "code": "class FileHandle {\n    FILE* file;\npublic:\n    FileHandle(const char* path) {\n        file = fopen(path, \"r\");\n        if (!file) throw std::runtime_error(\"Failed\");\n    }\n    \n    ~FileHandle() {\n        if (file) fclose(file);  // Всегда вызовется!\n    }\n    \n    // Запрещаем копирование\n    FileHandle(const FileHandle&) = delete;\n};\n\nFileHandle f(\"data.txt\");  // Файл откроется\n// При любом выходе из scope файл закроется"
    },
    {
        "category": "C++ Memory Management",
        "title": "Memory alignment и padding",
        "theory": "Процессор эффективно читает данные, выровненные по границам слова (4/8/16 байт). Компилятор добавляет padding между полями структуры для выравнивания. Это увеличивает размер, но ускоряет доступ. Можно контролировать через alignas или #pragma pack. SIMD инструкции требуют строгого alignment (16/32 байта), иначе crash.",
        "code": "struct BadLayout {  // Размер = 16 байт (с padding)\n    char a;     // 1 байт\n    // 3 байта padding\n    int b;      // 4 байта\n    char c;     // 1 байт\n    // 7 байт padding для выравнивания по 8\n};\n\nstruct GoodLayout {  // Размер = 12 байт\n    int b;      // 4 байта\n    char a;     // 1 байт\n    char c;     // 1 байт\n    // 2 байта padding\n};\n\nstatic_assert(sizeof(BadLayout) > sizeof(GoodLayout));"
    },
    {
        "category": "C++ Memory Management",
        "title": "Cache-friendly data structures",
        "theory": "CPU кэш работает блоками (cache lines, обычно 64 байта). Последовательный доступ к памяти быстрее: процессор загружает соседние данные в кэш. Array-of-Structures (AoS) против Structure-of-Arrays (SoA): SoA быстрее при обработке одного поля для многих объектов. Data-Oriented Design критичен в геймдеве для обработки тысяч объектов за 16ms.",
        "code": "// Array-of-Structures (плохо для кэша при частичной обработке)\nstruct Particle { float x, y, z, vx, vy, vz; };\nstd::vector<Particle> particles(10000);\nfor (auto& p : particles) p.x += p.vx;  // Загружаем всю структуру\n\n// Structure-of-Arrays (лучше для кэша)\nstruct ParticleSystem {\n    std::vector<float> x, y, z, vx, vy, vz;\n};\nParticleSystem ps;\nfor (size_t i = 0; i < ps.x.size(); ++i) {\n    ps.x[i] += ps.vx[i];  // Только x и vx, плотно в памяти\n}"
    },
    {
        "category": "C++ Memory Management",
        "title": "Custom allocators: зачем нужны",
        "theory": "Стандартный allocator (new/delete) медленный и фрагментирует память. Custom allocator позволяет контролировать стратегию выделения: pool allocator для объектов фиксированного размера, arena allocator для временных данных, stack allocator для LIFO паттернов. В играх может дать 10x прирост скорости и уменьшить фрагментацию.",
        "code": "// Pool allocator для частых аллокаций одного размера\ntemplate<typename T, size_t BlockSize = 4096>\nclass PoolAllocator {\n    struct Block { Block* next; };\n    Block* freeList = nullptr;\n    \npublic:\n    T* allocate() {\n        if (!freeList) {\n            // Выделяем блок\n            char* block = new char[BlockSize * sizeof(T)];\n            for (size_t i = 0; i < BlockSize; ++i) {\n                Block* b = (Block*)(block + i * sizeof(T));\n                b->next = freeList;\n                freeList = b;\n            }\n        }\n        Block* b = freeList;\n        freeList = b->next;\n        return (T*)b;\n    }\n};"
    },
    {
        "category": "C++ Threading",
        "title": "std::thread: создание потока",
        "theory": "std::thread создаёт новый поток выполнения. Принимает функцию и её аргументы. Поток начинает выполнение сразу. КРИТИЧНО: перед уничтожением thread нужно вызвать join() (ждать завершения) или detach() (отсоединить). Забыть join/detach — это std::terminate() и crash программы. В играх потоки используются для физики, AI, загрузки.",
        "code": "void workerFunction(int id, const std::string& msg) {\n    std::cout << \"Thread \" << id << \": \" << msg << std::endl;\n}\n\nstd::thread t1(workerFunction, 1, \"Hello\");\nstd::thread t2([](){ std::cout << \"Lambda thread\\n\"; });\n\n// ОБЯЗАТЕЛЬНО join или detach!\nt1.join();   // Ждём завершения\nt2.detach(); // Отсоединяем (поток работает независимо)\n\n// std::thread t3(someFunc);\n// Забыли join/detach — CRASH при выходе из scope!"
    },
    {
        "category": "C++ Threading",
        "title": "std::mutex: защита данных",
        "theory": "Mutex (mutual exclusion) защищает shared data от одновременного доступа. Поток вызывает lock() перед доступом, unlock() после. Только один поток может держать lock одновременно. НИКОГДА не используй голый lock/unlock — забудешь unlock = deadlock. Всегда используй RAII обёртки: lock_guard или unique_lock.",
        "code": "std::mutex mtx;\nint sharedCounter = 0;\n\nvoid increment(int times) {\n    for (int i = 0; i < times; ++i) {\n        std::lock_guard<std::mutex> lock(mtx);  // RAII!\n        ++sharedCounter;  // Защищено\n    }  // Автоматический unlock\n}\n\nstd::thread t1(increment, 1000);\nstd::thread t2(increment, 1000);\nt1.join(); t2.join();\n\nstd::cout << sharedCounter;  // Всегда 2000 (без data race)"
    },
    {
        "category": "C++ Threading",
        "title": "Race condition и data race",
        "theory": "Race condition — когда результат зависит от порядка выполнения потоков. Data race — когда два потока обращаются к одной переменной, хотя бы один пишет, без синхронизации. Data race = undefined behavior в C++! Может привести к непредсказуемым значениям, crashes, security уязвимостям. Всегда защищай shared data через mutex или atomics.",
        "code": "// DATA RACE (UB!):\nint counter = 0;\nstd::thread t1([&](){ for(int i=0; i<1000; ++i) ++counter; });\nstd::thread t2([&](){ for(int i=0; i<1000; ++i) ++counter; });\nt1.join(); t2.join();\n// counter может быть меньше 2000! Результат непредсказуем!\n\n// ИСПРАВЛЕНО:\nstd::mutex mtx;\nint counter2 = 0;\nstd::thread t3([&](){ for(int i=0; i<1000; ++i) {\n    std::lock_guard lock(mtx); ++counter2; }});\nstd::thread t4([&](){ for(int i=0; i<1000; ++i) {\n    std::lock_guard lock(mtx); ++counter2; }});\nt3.join(); t4.join();  // counter2 всегда 2000"
    },
    {
        "category": "C++ Threading",
        "title": "Deadlock: причины и профилактика",
        "theory": "Deadlock — ситуация когда два+ потока вечно ждут друг друга. Классика: поток A держит mutex1 и ждёт mutex2, поток B держит mutex2 и ждёт mutex1. Программа зависает навсегда. Решения: (1) всегда лочить мьютексы в одинаковом порядке, (2) использовать std::lock для одновременного лока нескольких мьютексов, (3) избегать вложенных локов.",
        "code": "std::mutex mtx1, mtx2;\n\n// DEADLOCK:\nvoid thread1() {\n    std::lock_guard lock1(mtx1);\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    std::lock_guard lock2(mtx2);  // Ждёт, если thread2 держит mtx2\n}\nvoid thread2() {\n    std::lock_guard lock2(mtx2);\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    std::lock_guard lock1(mtx1);  // Ждёт, если thread1 держит mtx1\n}\n\n// РЕШЕНИЕ: одинаковый порядок или std::lock\nvoid thread2_fixed() {\n    std::lock_guard lock1(mtx1);  // Тот же порядок!\n    std::lock_guard lock2(mtx2);\n}"
    },
    {
        "category": "C++ Threading",
        "title": "std::lock_guard vs std::unique_lock",
        "theory": "lock_guard — простой RAII wrapper для mutex. Лочит в конструкторе, анлочит в деструкторе. Нельзя анлочить вручную. unique_lock — более гибкий: можно lock/unlock вручную, можно defer lock (не лочить сразу), можно передать ownership. Цена: чуть больше overhead. Используй lock_guard по умолчанию, unique_lock когда нужна гибкость.",
        "code": "std::mutex mtx;\n\n// lock_guard (простой)\n{\n    std::lock_guard<std::mutex> lock(mtx);  // Залочен\n    // критическая секция\n}  // Автоматически разлочен, нельзя unlock() вручную\n\n// unique_lock (гибкий)\n{\n    std::unique_lock<std::mutex> lock(mtx);  // Залочен\n    // критическая секция\n    lock.unlock();  // Можем разлочить вручную\n    // некритический код\n    lock.lock();    // Можем залочить снова\n}  // Автоматически разлочен если был залочен"
    },
    {
        "category": "C++ Threading",
        "title": "std::condition_variable",
        "theory": "Condition variable позволяет потоку ждать пока другой поток не изменит условие. Избегает busy-waiting (постоянная проверка в цикле). Поток вызывает wait(), освобождая mutex и засыпая. Другой поток вызывает notify_one()/notify_all() чтобы разбудить. Критично использовать с предикатом для защиты от spurious wakeups. Основа для Producer-Consumer.",
        "code": "std::mutex mtx;\nstd::condition_variable cv;\nbool ready = false;\n\nvoid worker() {\n    std::unique_lock<std::mutex> lock(mtx);\n    cv.wait(lock, []{ return ready; });  // Ждём пока ready == true\n    std::cout << \"Worker started!\\n\";\n}\n\nvoid signaler() {\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    {\n        std::lock_guard<std::mutex> lock(mtx);\n        ready = true;\n    }\n    cv.notify_one();  // Будим один поток\n}"
    },
    {
        "category": "C++ Threading",
        "title": "std::atomic: lock-free синхронизация",
        "theory": "std::atomic обеспечивает атомарные операции без мьютексов. Операции read/write/RMW (read-modify-write) выполняются как одна неделимая инструкция. Поддерживается для простых типов (int, bool, указатели). Быстрее мьютексов, но сложнее в использовании. Идеально для простых счётчиков, флагов. В играх — для lock-free очередей, флагов завершения.",
        "code": "std::atomic<int> counter(0);\n\nvoid increment() {\n    for (int i = 0; i < 1000; ++i) {\n        counter.fetch_add(1);  // Атомарно, без mutex!\n        // или просто: counter++;\n    }\n}\n\nstd::thread t1(increment);\nstd::thread t2(increment);\nt1.join(); t2.join();\n\nstd::cout << counter.load();  // Всегда 2000 (нет data race)\n// Гораздо быстрее чем с mutex для простых операций"
    },
    {
        "category": "C++ Threading",
        "title": "Memory ordering: основы",
        "theory": "Memory ordering определяет как операции одного потока видны другим. По умолчанию std::memory_order_seq_cst (sequential consistency) — самый строгий и медленный. Более слабые: acquire-release для синхронизации, relaxed для независимых операций. Relaxed самый быстрый, но не гарантирует порядок. Критично для high-performance lock-free структур.",
        "code": "std::atomic<bool> ready(false);\nstd::atomic<int> data(0);\n\n// Writer thread\ndata.store(42, std::memory_order_relaxed);     // Порядок не важен\nready.store(true, std::memory_order_release);  // \"Выпускаем\" данные\n\n// Reader thread\nwhile (!ready.load(std::memory_order_acquire)) {}  // \"Захватываем\"\nint value = data.load(std::memory_order_relaxed);  // Гарантированно 42\n\n// acquire-release гарантирует: все записи до release\n// видны после acquire"
    },
    {
        "category": "C++ Threading",
        "title": "std::future и std::promise",
        "theory": "std::promise позволяет одному потоку установить значение, которое другой прочитает через std::future. Future — это \"получатель\" результата из другого потока. Promise — \"отправитель\". Однократное использование: promise.set_value() можно вызвать только раз. Идеально для передачи одного результата из worker thread в main thread.",
        "code": "void computeSquare(std::promise<int> prom, int x) {\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    prom.set_value(x * x);  // Отправляем результат\n}\n\nstd::promise<int> prom;\nstd::future<int> fut = prom.get_future();\n\nstd::thread t(computeSquare, std::move(prom), 10);\n\nstd::cout << \"Waiting...\\n\";\nint result = fut.get();  // Блокируется пока не придёт результат\nstd::cout << \"Result: \" << result;  // 100\nt.join();"
    },
    {
        "category": "C++ Threading",
        "title": "std::async: task-based parallelism",
        "theory": "std::async запускает функцию асинхронно и возвращает std::future для получения результата. Проще чем создавать thread вручную. std::launch::async гарантирует новый поток, std::launch::deferred откладывает выполнение до fut.get(). Автоматически управляет потоками. Идеален для параллелизации независимых задач без low-level управления потоками.",
        "code": "int computeHeavy(int x) {\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    return x * x;\n}\n\n// Запуск асинхронно\nauto fut1 = std::async(std::launch::async, computeHeavy, 10);\nauto fut2 = std::async(std::launch::async, computeHeavy, 20);\n\nstd::cout << \"Computing...\\n\";\n// Делаем другую работу\n\nint result1 = fut1.get();  // Ждём результат 1\nint result2 = fut2.get();  // Ждём результат 2\nstd::cout << result1 + result2;  // 100 + 400 = 500"
    },
    {
        "category": "C++ Threading",
        "title": "Thread pool pattern",
        "theory": "Thread pool — это набор заранее созданных потоков, которые берут задачи из очереди. Избегает overhead создания/удаления потоков для каждой задачи. Задачи добавляются в очередь, свободные потоки их забирают. В играх стандарт для Job Systems: physics, AI, rendering tasks идут в пул. Оптимальное количество потоков ≈ количество ядер CPU.",
        "code": "class ThreadPool {\n    std::vector<std::thread> workers;\n    std::queue<std::function<void()>> tasks;\n    std::mutex mtx;\n    std::condition_variable cv;\n    bool stop = false;\n    \npublic:\n    ThreadPool(size_t numThreads) {\n        for (size_t i = 0; i < numThreads; ++i) {\n            workers.emplace_back([this] {\n                while (true) {\n                    std::function<void()> task;\n                    {\n                        std::unique_lock lock(mtx);\n                        cv.wait(lock, [this]{ return stop || !tasks.empty(); });\n                        if (stop && tasks.empty()) return;\n                        task = std::move(tasks.front());\n                        tasks.pop();\n                    }\n                    task();\n                }\n            });\n        }\n    }\n    \n    template<typename F>\n    void enqueue(F&& f) {\n        {\n            std::lock_guard lock(mtx);\n            tasks.emplace(std::forward<F>(f));\n        }\n        cv.notify_one();\n    }\n    \n    ~ThreadPool() {\n        {\n            std::lock_guard lock(mtx);\n            stop = true;\n        }\n        cv.notify_all();\n        for (auto& t : workers) t.join();\n    }\n};\n\n// Использование\nThreadPool pool(4);\npool.enqueue([]{ std::cout << \"Task 1\\n\"; });\npool.enqueue([]{ std::cout << \"Task 2\\n\"; });"
    },
    {
        "category": "C++ Threading",
        "title": "Producer-Consumer pattern",
        "theory": "Producer-Consumer — классический паттерн многопоточности. Producer добавляет элементы в очередь, Consumer забирает и обрабатывает. Нужна синхронизация через mutex и condition_variable. Producer уведомляет Consumer когда добавил элемент. Consumer ждёт если очередь пуста. В играх используется для асинхронной загрузки ресурсов, обработки событий.",
        "code": "std::queue<int> buffer;\nstd::mutex mtx;\nstd::condition_variable cv;\nbool done = false;\n\nvoid producer() {\n    for (int i = 0; i < 10; ++i) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n        {\n            std::lock_guard lock(mtx);\n            buffer.push(i);\n            std::cout << \"Produced: \" << i << std::endl;\n        }\n        cv.notify_one();  // Будим consumer\n    }\n    done = true;\n    cv.notify_all();\n}\n\nvoid consumer() {\n    while (true) {\n        std::unique_lock lock(mtx);\n        cv.wait(lock, []{ return !buffer.empty() || done; });\n        while (!buffer.empty()) {\n            int val = buffer.front();\n            buffer.pop();\n            lock.unlock();\n            std::cout << \"Consumed: \" << val << std::endl;\n            std::this_thread::sleep_for(std::chrono::milliseconds(150));\n            lock.lock();\n        }\n        if (done && buffer.empty()) break;\n    }\n}"
    }
]
