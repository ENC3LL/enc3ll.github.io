[
    {
        "name": "Move Semantics Основы",
        "cards": [
            {
                "title": "lvalue и rvalue",
                "theory": "В C++ каждое выражение — либо lvalue (объект с именем и адресом), либо rvalue (временное значение). Когда ты пишешь игру, переменные игрока — lvalue, а результаты вычислений (player.health + damage) — rvalue. Это важно для оптимизации: временные объекты можно переиспользовать вместо копирования.",
                "code": "// lvalue — это переменная с именем\nint health = 100;\nint* ptr = &health;  // можем взять адрес\n\n// rvalue — временное значение\nint damage = health - 50;\n// (health - 50) исчезает после вычисления\n\n// int* bad = &(health - 50);  // ОШИБКА"
            },
            {
                "title": "Зачем нужны rvalue references",
                "theory": "В играх постоянно создаются временные объекты: результаты физики, новые позиции объектов, загруженные ресурсы. rvalue reference (Type&&) позволяет \"забрать\" данные из временного объекта вместо копирования. Это как взять чемодан у уезжающего человека вместо покупки нового и перекладывания вещей.",
                "code": "using namespace std;\n\n// Функция принимает временный объект\nvoid useTexture(string&& tempPath) {\n    cout << \"Загружаем: \" << tempPath << endl;\n}\n\n// Временная строка передаётся эффективно\nuseTexture(\"hero_texture.png\");\n\n// Постоянную переменную нужно явно \"переместить\"\nstring path = \"enemy.png\";\n// useTexture(path);  // ОШИБКА: path — lvalue"
            },
            {
                "title": "Move constructor",
                "theory": "В игре у тебя есть класс Texture с большим массивом пикселей (допустим, 4K текстура = 30+ МБ). Копирование такого объекта при каждой передаче убьёт производительность. Move constructor забирает данные из временного объекта, оставляя его пустым. Это работает в 100+ раз быстрее копирования больших данных.",
                "code": "class Texture {\n    unsigned char* pixels;\n    int width, height;\n    \npublic:\n    // Move constructor — забираем данные\n    Texture(Texture&& other) noexcept {\n        // Копируем указатели (быстро)\n        pixels = other.pixels;\n        width = other.width;\n        height = other.height;\n        \n        // Обнуляем источник\n        other.pixels = nullptr;\n        other.width = 0;\n        other.height = 0;\n    }\n};"
            },
            {
                "title": "std::move — как работает",
                "theory": "std::move НЕ перемещает данные! Он просто говорит компилятору: \"эта переменная мне больше не нужна, можешь забрать её содержимое\". Реальное перемещение делает move constructor. После std::move переменная становится \"зомби\" — технически жива, но использовать её опасно. Можно только переприсвоить или уничтожить.",
                "code": "using namespace std;\n\nvector<int> inventory = {1, 2, 3, 4, 5};\n\n// Передаём владение другому вектору\nvector<int> newInventory = move(inventory);\n\n// inventory теперь пустой!\n// cout << inventory[0];  // ОПАСНО!\n\n// Можно переприсвоить\ninventory = {10, 20, 30};  // OK\n\n// Можно проверить размер\ncout << inventory.size();  // 3"
            },
            {
                "title": "Perfect Forwarding",
                "theory": "В игре у тебя есть фабрика объектов (EntityFactory), которая создаёт врагов, игрока, NPC. Ей нужно передать параметры конструктора максимально эффективно. Perfect forwarding передаёт аргументы \"как есть\": временные как временные (move), постоянные как постоянные (copy). Это основа всех фабрик и wrapper-функций в Unreal Engine.",
                "code": "using namespace std;\n\n// T&& в шаблоне = forwarding reference\ntemplate<typename T>\nvoid createEnemy(T&& name) {\n    // forward сохраняет \"категорию\" аргумента\n    Enemy enemy(forward<T>(name));\n}\n\nstring bossName = \"Dragon\";\n\n// Постоянная переменная — копируется\ncreateEnemy(bossName);\n\n// Временное значение — перемещается\ncreateEnemy(\"Goblin\");"
            }
        ]
    },
    {
        "name": "Smart Pointers",
        "cards": [
            {
                "title": "unique_ptr — единоличное владение",
                "theory": "В игре у игрока есть оружие. Оружие принадлежит ТОЛЬКО ему, никто другой не может им пользоваться одновременно. unique_ptr работает так же — один владелец, автоматическое удаление при уничтожении. Никаких memory leaks, даже если произошло исключение. В Unreal Engine похожая система — TUniquePtr.",
                "code": "using namespace std;\n\n// Создаём оружие (рекомендуемый способ)\nauto weapon = make_unique<Weapon>(\"Sword\", 50);\n\n// Используем как обычный указатель\nweapon->attack();\ncout << weapon->getDamage();  // 50\n\n// Проверка на nullptr\nif (weapon) {\n    weapon->repair();\n}\n\n// Память освободится автоматически!"
            },
            {
                "title": "unique_ptr — передача владения",
                "theory": "Игрок выбросил оружие, и его подобрал другой игрок. Владение переходит от одного к другому. После передачи первый игрок больше не имеет доступа к оружию. В коде это std::move — явная передача владения. Попытка использовать старый указатель после move приведёт к краш",
                "code": "using namespace std;\n\nauto player1Weapon = make_unique<Weapon>(\"Axe\", 70);\n\n// Передаём владение другому игроку\nauto player2Weapon = move(player1Weapon);\n\n// player1Weapon теперь nullptr!\nif (!player1Weapon) {\n    cout << \"У игрока 1 нет оружия\" << endl;\n}\n\n// player2Weapon владеет оружием\nplayer2Weapon->attack();"
            },
            {
                "title": "shared_ptr — разделяемое владение",
                "theory": "Текстура героя используется в: UI (портрет), игровом мире (модель), миникарте (иконка). Все они нужны одновременно. shared_ptr позволяет нескольким объектам владеть одним ресурсом. Текстура удалится только когда последний владелец её отпустит. Это стандарт для разделяемых ресурсов в движках.",
                "code": "using namespace std;\n\n// Загружаем текстуру\nauto heroTexture = make_shared<Texture>(\"hero.png\");\n\n// UI использует эту же текстуру\nauto uiPortrait = heroTexture;  // счётчик = 2\n\n// Миникарта тоже\nauto minimapIcon = heroTexture;  // счётчик = 3\n\ncout << heroTexture.use_count();  // 3\n\n// UI удалили, но текстура жива\nuiPortrait.reset();  // счётчик = 2"
            },
            {
                "title": "shared_ptr — циклические ссылки",
                "theory": "Опасность: родитель хранит shared_ptr на ребёнка, ребёнок на родителя. Оба счётчика никогда не обнулятся = memory leak. В игровых сценах это частая проблема: GameObject → Component, Component → GameObject. Решение: одна связь делается через weak_ptr (обычно child → parent).",
                "code": "using namespace std;\n\nstruct GameObject {\n    shared_ptr<Component> comp;\n};\n\nstruct Component {\n    shared_ptr<GameObject> owner;  // ПРОБЛЕМА!\n};\n\nauto obj = make_shared<GameObject>();\nauto cmp = make_shared<Component>();\n\nobj->comp = cmp;   // счётчики = 2\ncmp->owner = obj;  // счётчики = 2\n\n// При выходе: счётчики = 1\n// Объекты НЕ удаляются = leak!"
            },
            {
                "title": "weak_ptr — разрыв циклов",
                "theory": "weak_ptr — это \"наблюдатель\" за объектом, который не мешает его удалению. Компонент знает о своём GameObject через weak_ptr. Если GameObject удалился, компонент это обнаружит. Перед использованием нужно \"повысить\" weak_ptr до shared_ptr через lock(). Если объект мёртв, вернётся nullptr.",
                "code": "using namespace std;\n\nstruct GameObject {\n    shared_ptr<Component> comp;\n};\n\nstruct Component {\n    weak_ptr<GameObject> owner;  // Слабая ссылка!\n    \n    void update() {\n        // Проверяем, жив ли владелец\n        if (auto obj = owner.lock()) {\n            obj->doSomething();\n        } else {\n            cout << \"Владелец удалён!\" << endl;\n        }\n    }\n};"
            },
            {
                "title": "Когда какой указатель использовать",
                "theory": "unique_ptr — дефолт для всего. Mesh игрока, его AI контроллер, компоненты — всё через unique_ptr. shared_ptr — только когда ресурс действительно разделяется: текстуры, звуки, материалы. weak_ptr — для разрыва циклов и кэшей. Сырой указатель (T*) — только для \"наблюдения\" (например, параметры функций).",
                "code": "using namespace std;\n\nclass GameObject {\n    // Владеем эксклюзивно\n    unique_ptr<Mesh> mesh;\n    unique_ptr<AIController> ai;\n    \n    // Разделяем с другими объектами\n    shared_ptr<Texture> texture;\n    shared_ptr<Material> material;\n    \n    // Наблюдаем без владения\n    weak_ptr<GameObject> target;\n    GameObject* parent;  // Не владеем\n};"
            }
        ]
    },
    {
        "name": "Lambda Выражения",
        "cards": [
            {
                "title": "Lambda — анонимная функция",
                "theory": "В игре тебе нужно отсортировать врагов по здоровью, или найти всех врагов в радиусе. Lambda позволяет написать логику прямо на месте, без создания отдельной функции. Синтаксис: [] — что захватить, () — параметры, {} — тело. Компилятор оптимизирует так же хорошо, как обычные функции.",
                "code": "using namespace std;\n\nvector<int> scores = {85, 92, 78, 95};\n\n// Сортируем по убыванию прямо здесь\nsort(scores.begin(), scores.end(),\n    [](int a, int b) {\n        return a > b;\n    }\n);\n\n// scores теперь: {95, 92, 85, 78}"
            },
            {
                "title": "Захват переменных — по значению",
                "theory": "У тебя есть damage модификатор игрока (например, +50% от зелья). Нужно применить его ко всем атакам. Захват [=] копирует все переменные в lambda. Lambda работает со своей копией, оригиналы не меняются. Безопасно, но может быть медленно для больших объектов.",
                "code": "using namespace std;\n\nint damageBonus = 50;\nvector<int> attacks = {100, 120, 80};\n\n// Захватываем damageBonus по значению\nfor_each(attacks.begin(), attacks.end(),\n    [=](int& attack) {\n        // Используем КОПИЮ damageBonus\n        attack += damageBonus;\n    }\n);\n\n// attacks: {150, 170, 130}\n// damageBonus не изменился: 50"
            },
            {
                "title": "Захват переменных — по ссылке",
                "theory": "Считаем сколько врагов убито за уровень. Счётчик нужно увеличивать из lambda. Захват [&] даёт доступ к оригинальным переменным, можно их менять. Эффективно, но опасно: если lambda переживёт переменную, получим dangling reference и краш.",
                "code": "using namespace std;\n\nint enemiesKilled = 0;\nvector<Enemy> enemies = {/*...*/};\n\n// Захватываем счётчик по ссылке\nfor_each(enemies.begin(), enemies.end(),\n    [&](Enemy& e) {\n        if (e.health <= 0) {\n            // Меняем оригинальный счётчик\n            enemiesKilled++;\n        }\n    }\n);\n\ncout << \"Убито: \" << enemiesKilled;"
            },
            {
                "title": "Mutable lambda — хранение состояния",
                "theory": "Нужно подсчитать комбо-удары: каждый следующий удар наносит больше урона. Lambda должна помнить количество ударов между вызовами. mutable позволяет менять захваченные копии переменных. Это как мини-объект с состоянием.",
                "code": "using namespace std;\n\n// Lambda с состоянием (счётчик комбо)\nauto comboAttack = [combo = 0]() mutable {\n    combo++;  // Увеличиваем КОПИЮ\n    int damage = 100 * combo;\n    cout << \"Комбо x\" << combo \n         << \", урон: \" << damage << endl;\n    return damage;\n};\n\ncomboAttack();  // Комбо x1, урон: 100\ncomboAttack();  // Комбо x2, урон: 200\ncomboAttack();  // Комбо x3, урон: 300"
            },
            {
                "title": "Generic lambda — любой тип",
                "theory": "Функция вывода в лог должна работать с числами, строками, векторами. Generic lambda с auto принимает любой тип. Компилятор создаёт версию под каждый тип автоматически. Это как шаблонная функция, но проще в написании.",
                "code": "using namespace std;\n\n// Lambda работает с ЛЮБЫМ типом\nauto printValue = [](const auto& value) {\n    cout << \"Значение: \" << value << endl;\n};\n\nprintValue(42);          // int\nprintValue(3.14);        // double\nprintValue(\"Hello\");    // строка\n\nvector<int> vec = {1, 2, 3};\n// Можно даже вектор (если есть operator<<)"
            }
        ]
    },
    {
        "name": "Type Inference",
        "cards": [
            {
                "title": "auto — автовывод типа",
                "theory": "В игровом коде часто встречаются длинные типы: map<string, vector<shared_ptr<Texture>>>. Писать это каждый раз — боль. auto выводит тип автоматически из значения справа. Код становится чище, но тип должен быть понятен из контекста. В Unreal Engine почти весь код использует auto.",
                "code": "using namespace std;\n\n// Без auto (длинно и неудобно)\nvector<int>::iterator it = enemies.begin();\n\n// С auto (чисто и понятно)\nauto it2 = enemies.begin();\n\n// Для сложных типов\nmap<string, int> scores;\nauto result = scores.insert({\"player\", 100});\n\n// auto ДОЛЖНА быть инициализирована\n// auto x;  // ОШИБКА"
            },
            {
                "title": "auto& — ссылка без копирования",
                "theory": "При итерации по вектору врагов auto создаёт КОПИЮ каждого врага. Для больших объектов это медленно. auto& создаёт ссылку — никакого копирования. const auto& для чтения, auto& для изменения. В петлях по контейнерам это стандарт для производительности.",
                "code": "using namespace std;\n\nvector<Enemy> enemies = {/*...*/};\n\n// auto — копирует каждого врага (МЕДЛЕННО!)\nfor (auto enemy : enemies) {\n    enemy.health -= 10;  // Меняем КОПИЮ\n}\n\n// auto& — работает с оригиналами\nfor (auto& enemy : enemies) {\n    enemy.health -= 10;  // Меняем ОРИГИНАЛ\n}\n\n// const auto& — только чтение\nfor (const auto& enemy : enemies) {\n    cout << enemy.name;\n}"
            },
            {
                "title": "decltype — точный тип выражения",
                "theory": "auto иногда \"теряет\" ссылки и const. decltype сохраняет ТОЧНЫЙ тип выражения, включая все модификаторы. Нужно в шаблонах и метапрограммировании, когда критично сохранить все свойства типа. В обычном коде используется редко.",
                "code": "using namespace std;\n\nint x = 42;\nint& ref = x;\n\n// auto отбрасывает ссылку\nauto a = ref;  // int (не ссылка!)\na = 100;       // x не изменится\n\n// decltype сохраняет ссылку\ndecltype(ref) b = x;  // int&\nb = 100;              // x = 100!\n\nvector<int> vec;\n// decltype даёт точный тип\ndecltype(vec[0]) elem = vec[0];  // int&"
            }
        ]
    },
    {
        "name": "STL Containers",
        "cards": [
            {
                "title": "vector — динамический массив",
                "theory": "vector — самый используемый контейнер в играх. Хранит элементы последовательно в памяти (cache-friendly). При заполнении увеличивается в 1.5-2 раза, копируя данные в новый блок. reserve() предвыделяет память, избегая реаллокаций. Используй для списков врагов, пуль, частиц — всего, где важна скорость итерации.",
                "code": "using namespace std;\n\nvector<Enemy> enemies;\n\n// Предвыделяем память для 100 врагов\nenemies.reserve(100);\n\n// Добавляем врагов (без реаллокаций)\nfor (int i = 0; i < 100; i++) {\n    enemies.push_back(Enemy());\n}\n\ncout << enemies.size();      // 100\ncout << enemies.capacity();  // >= 100\n\n// Освобождаем лишнюю память\nenemies.shrink_to_fit();"
            },
            {
                "title": "vector — emplace vs push",
                "theory": "push_back создаёт объект снаружи, потом копирует/перемещает его в вектор. emplace_back создаёт объект СРАЗУ внутри вектора из аргументов. Для сложных объектов (Enemy с текстурами, AI) это экономит копирование и ускоряет код. В боевых системах может дать 20-30% прирост скорости.",
                "code": "using namespace std;\n\nvector<Enemy> enemies;\n\n// push_back: создаём объект, потом перемещаем\nenemies.push_back(Enemy(\"Orc\", 100, 50));\n// 1 конструктор + 1 move constructor\n\n// emplace_back: создаём СРАЗУ в векторе\nenemies.emplace_back(\"Goblin\", 50, 30);\n// Только 1 конструктор!\n\n// Разница критична для больших объектов\nenemies.emplace_back(name, health, damage);"
            },
            {
                "title": "map — упорядоченный словарь",
                "theory": "map хранит пары ключ-значение отсортированными по ключу. Реализован как красно-чёрное дерево. Поиск, вставка, удаление — O(log n). Используй для настроек игры, статистики игрока, баз данных предметов — где нужен упорядоченный доступ по ключу.",
                "code": "using namespace std;\n\nmap<string, int> inventory;\n\n// Добавляем предметы\ninventory[\"Potion\"] = 5;\ninventory[\"Sword\"] = 1;\ninventory.insert({\"Shield\", 1});\n\n// Поиск предмета\nif (inventory.find(\"Potion\") != inventory.end()) {\n    cout << \"Есть зелья!\" << endl;\n}\n\n// Итерация в алфавитном порядке\nfor (const auto& [item, count] : inventory) {\n    cout << item << \": \" << count << endl;\n}"
            },
            {
                "title": "unordered_map — хеш-таблица",
                "theory": "unordered_map — это хеш-таблица с O(1) доступом в среднем. Быстрее map, но элементы не упорядочены. Идеален для быстрого поиска: EntityID → GameObject, TextureName → Texture. В играх используется везде, где критична скорость lookup. Unreal Engine хранит все Actor'ы в unordered_map по ID.",
                "code": "using namespace std;\n\nunordered_map<int, GameObject*> entities;\n\n// Быстрое добавление O(1)\nentities[1001] = new GameObject(\"Player\");\nentities[2042] = new GameObject(\"Enemy\");\n\n// Мгновенный поиск по ID\nauto it = entities.find(1001);\nif (it != entities.end()) {\n    it->second->update();\n}\n\n// Предвыделяем под 10000 объектов\nentities.reserve(10000);"
            },
            {
                "title": "string_view — взгляд на строку",
                "theory": "Передача string в функцию копирует всю строку. Для имён файлов, путей, логов это расточительно. string_view — это указатель + длина, БЕЗ копирования. Работает в 10+ раз быстрее. Опасность: не владеет данными, если оригинальная строка удалится — краш. Используй только для чтения.",
                "code": "using namespace std;\n\n// Принимаем string_view (нет копирования)\nvoid loadTexture(string_view path) {\n    cout << \"Загрузка: \" << path << endl;\n}\n\nstring texturePath = \"hero.png\";\nconst char* cstr = \"enemy.png\";\n\nloadTexture(texturePath);  // OK\nloadTexture(cstr);         // OK\nloadTexture(\"boss.png\");   // OK\n\n// Все вызовы БЕЗ копирования строк!"
            }
        ]
    },
    {
        "name": "Memory Management",
        "cards": [
            {
                "title": "Stack vs Heap память",
                "theory": "Stack — автоматическая память, выделяется/освобождается мгновенно при входе/выходе из функции. Размер ограничен (1-8 МБ). Heap — динамическая память через new/malloc, медленная (системный вызов), но размер почти неограничен. В играх критично: stack для локальных переменных, heap для больших объектов. Минимизируй heap allocations в игровом цикле.",
                "code": "void gameLoop() {\n    // STACK — мгновенное выделение\n    int health = 100;\n    float position[3] = {0, 0, 0};\n    // Освобождается автоматически\n    \n    // HEAP — медленное выделение\n    int* largeArray = new int[10000];\n    // Нужно удалить вручную\n    delete[] largeArray;\n    \n    // ~100 наносекунд vs ~1 наносекунда\n}"
            },
            {
                "title": "RAII — автоматическое управление",
                "theory": "RAII = Resource Acquisition Is Initialization. Ресурс (файл, память, мьютекс) получаем в конструкторе, освобождаем в деструкторе. Даже если вылетит исключение или early return — деструктор вызовется, ресурс освободится. Это основа C++: smart pointers, lock_guard, fstream — всё на RAII. В отличие от Java/C# нет garbage collector, но есть детерминизм.",
                "code": "class TextureLoader {\n    FILE* file;\npublic:\n    // Открываем в конструкторе\n    TextureLoader(const char* path) {\n        file = fopen(path, \"rb\");\n        if (!file) throw runtime_error(\"Fail\");\n    }\n    \n    // Закрываем в деструкторе\n    ~TextureLoader() {\n        if (file) fclose(file);\n        // Вызовется ВСЕГДА!\n    }\n};\n\nTextureLoader loader(\"tex.png\");\n// Файл закроется автоматически"
            },
            {
                "title": "Cache-friendly структуры",
                "theory": "CPU читает память блоками по 64 байта (cache line). Если данные лежат рядом — быстро, если разбросаны — медленно. Structure-of-Arrays (SoA) быстрее Array-of-Structures (AoS) при обработке одного поля. В играх для 10000 частиц разница 2-5x в скорости. Data-Oriented Design — это стандарт в AAA играх.",
                "code": "// AoS — плохо для кэша\nstruct Particle {\n    float x, y, z;     // 12 байт\n    float vx, vy, vz;  // 12 байт\n};\nvector<Particle> particles(10000);\n\n// Обновляем только позицию\nfor (auto& p : particles) {\n    p.x += p.vx;  // Грузим всю структуру\n}\n\n// SoA — отлично для кэша\nstruct ParticleSystem {\n    vector<float> x, vx;  // Рядом!\n};\nfor (int i = 0; i < x.size(); i++) {\n    x[i] += vx[i];  // Только нужные данные\n}"
            },
            {
                "title": "Memory alignment",
                "theory": "Процессор любит данные, выровненные по границам 4/8/16 байт. Компилятор добавляет padding между полями для выравнивания. Это увеличивает размер, но ускоряет доступ. SIMD инструкции (SSE, AVX) требуют alignment 16/32 байта, иначе краш. Порядок полей в struct влияет на размер — размещай большие типы первыми.",
                "code": "// Плохой порядок — 16 байт\nstruct Bad {\n    char a;    // 1 байт\n    // 3 байта padding\n    int b;     // 4 байта\n    char c;    // 1 байт\n    // 7 байт padding\n};\n\n// Хороший порядок — 12 байт\nstruct Good {\n    int b;     // 4 байта\n    char a;    // 1 байт\n    char c;    // 1 байт\n    // 2 байта padding\n};\n\nstatic_assert(sizeof(Bad) > sizeof(Good));"
            }
        ]
    },
    {
        "name": "Threading Основы",
        "cards": [
            {
                "title": "std::thread — создание потока",
                "theory": "В игре физика, AI, рендеринг работают параллельно на разных ядрах CPU. thread создаёт новый поток выполнения для функции. КРИТИЧНО: перед уничтожением нужно join() (дождаться) или detach() (отпустить). Забыл — программа крашится. В Unreal Engine есть FRunnable, но принцип тот же.",
                "code": "using namespace std;\n\nvoid calculatePhysics() {\n    // Симуляция физики\n    cout << \"Физика работает\" << endl;\n}\n\n// Создаём поток\nthread physicsThread(calculatePhysics);\n\n// Основной поток делает своё\ncout << \"Рендерим кадр\" << endl;\n\n// ОБЯЗАТЕЛЬНО ждём завершения\nphysicsThread.join();\n\n// Забыли join — КРАШ!"
            },
            {
                "title": "mutex — защита данных",
                "theory": "Два потока одновременно пишут в счётчик убитых врагов. Получается data race — undefined behavior, счётчик теряет значения. mutex (mutual exclusion) пропускает только один поток. Всегда используй lock_guard — автоматически разлокает даже при исключении. В играх защищай любые данные, к которым обращаются разные потоки.",
                "code": "using namespace std;\n\nmutex mtx;\nint enemiesKilled = 0;\n\nvoid workerThread() {\n    for (int i = 0; i < 1000; i++) {\n        // Автоматический lock/unlock\n        lock_guard<mutex> lock(mtx);\n        enemiesKilled++;\n    }  // unlock здесь\n}\n\nthread t1(workerThread);\nthread t2(workerThread);\nt1.join(); t2.join();\n\ncout << enemiesKilled;  // Всегда 2000"
            },
            {
                "title": "Data race — главная опасность",
                "theory": "Data race = два потока обращаются к переменной, минимум один пишет, без синхронизации. Это undefined behavior в C++: переменная может содержать мусор, программа может крашиться, security дыры. ВСЕГДА защищай shared данные через mutex или atomics. В релизных играх баги от data race появляются случайно и их невозможно воспроизвести.",
                "code": "// DATA RACE — ОПАСНО!\nint score = 0;\n\nthread t1([&]() {\n    for (int i = 0; i < 1000; i++)\n        score++;  // Опасно!\n});\n\nthread t2([&]() {\n    for (int i = 0; i < 1000; i++)\n        score++;  // Опасно!\n});\n\nt1.join(); t2.join();\n// score может быть 1500 вместо 2000!\n// Непредсказуемый результат каждый раз"
            },
            {
                "title": "Deadlock — вечное ожидание",
                "theory": "Поток A ждёт mutex1 держа mutex2. Поток B ждёт mutex2 держа mutex1. Оба застряли навсегда. Программа зависает. Решение: всегда лочь мьютексы в одном порядке. Или использовать scoped_lock для атомарного захвата нескольких мьютексов. В играх deadlock = полное зависание, приходится убивать процесс.",
                "code": "using namespace std;\n\nmutex mtx1, mtx2;\n\n// DEADLOCK — программа зависнет\nvoid thread1() {\n    lock_guard lock1(mtx1);\n    this_thread::sleep_for(10ms);\n    lock_guard lock2(mtx2);  // Ждёт\n}\n\nvoid thread2() {\n    lock_guard lock2(mtx2);\n    this_thread::sleep_for(10ms);\n    lock_guard lock1(mtx1);  // Ждёт\n}\n\n// РЕШЕНИЕ — одинаковый порядок\nvoid thread2_fixed() {\n    lock_guard lock1(mtx1);  // Как в thread1\n    lock_guard lock2(mtx2);\n}"
            },
            {
                "title": "atomic — быстрая синхронизация",
                "theory": "mutex медленный для простых операций типа counter++. atomic использует lock-free инструкции процессора. Чтение/запись атомарны без блокировок. Идеально для флагов, счётчиков, простых состояний. В играх: флаги завершения потоков, счётчики кадров, простая статистика. В 10+ раз быстрее mutex для таких задач.",
                "code": "using namespace std;\n\natomic<int> frameCount(0);\natomic<bool> gameRunning(true);\n\nvoid renderThread() {\n    while (gameRunning.load()) {\n        // Рендерим кадр\n        frameCount++;  // Атомарно!\n    }\n}\n\nthread renderer(renderThread);\n\n// Через 5 секунд останавливаем\nthis_thread::sleep_for(5s);\ngameRunning = false;  // Атомарно!\n\nrenderer.join();\ncout << \"Кадров: \" << frameCount;"
            }
        ]
    },
    {
        "name": "Threading Продвинутое",
        "cards": [
            {
                "title": "condition_variable — ожидание события",
                "theory": "Поток-загрузчик ждёт задач в очереди. Без condition_variable пришлось бы крутить цикл проверки (busy-wait), тратя CPU. condition_variable позволяет потоку заснуть и проснуться только когда появится задача. Основа Producer-Consumer паттерна. В играх: системы загрузки ресурсов, обработка событий.",
                "code": "using namespace std;\n\nmutex mtx;\ncondition_variable cv;\nbool taskReady = false;\n\nvoid worker() {\n    unique_lock<mutex> lock(mtx);\n    // Ждём пока taskReady == true\n    cv.wait(lock, []{ return taskReady; });\n    cout << \"Задача выполняется!\" << endl;\n}\n\nvoid main_thread() {\n    this_thread::sleep_for(1s);\n    {\n        lock_guard lock(mtx);\n        taskReady = true;\n    }\n    cv.notify_one();  // Будим worker\n}"
            },
            {
                "title": "future и promise — передача результата",
                "theory": "Поток-загрузчик загружает текстуру, основной поток ждёт результат. promise отправляет значение, future получает. Однократное использование. Удобно для получения результата из background потока. В Unreal Engine похожая система — TFuture.",
                "code": "using namespace std;\n\nvoid loadTexture(promise<Texture> prom) {\n    // Загружаем текстуру (долго)\n    this_thread::sleep_for(2s);\n    Texture tex = loadFromDisk(\"hero.png\");\n    \n    // Отправляем результат\n    prom.set_value(tex);\n}\n\npromise<Texture> prom;\nfuture<Texture> fut = prom.get_future();\n\nthread loader(loadTexture, move(prom));\n\n// Ждём результат (блокируется)\nTexture result = fut.get();\ncout << \"Текстура загружена!\" << endl;\n\nloader.join();"
            },
            {
                "title": "async — простая параллелизация",
                "theory": "Нужно параллельно вычислить path-finding для 10 юнитов. async запускает функцию в отдельном потоке и возвращает future. Проще чем создавать thread вручную. Автоматически управляет потоками. Идеален для независимых задач: расчёт освещения, генерация мира, компрессия данных.",
                "code": "using namespace std;\n\nPath calculatePath(Vector3 start, Vector3 end) {\n    // A* алгоритм (долго)\n    this_thread::sleep_for(1s);\n    return findPath(start, end);\n}\n\n// Запускаем 3 задачи параллельно\nauto path1 = async(launch::async,\n    calculatePath, pos1, target1);\nauto path2 = async(launch::async,\n    calculatePath, pos2, target2);\nauto path3 = async(launch::async,\n    calculatePath, pos3, target3);\n\n// Получаем результаты\nPath p1 = path1.get();\nPath p2 = path2.get();\nPath p3 = path3.get();"
            },
            {
                "title": "Thread pool — переиспользование потоков",
                "theory": "Создание thread для каждой задачи медленное (системный вызов). Thread pool — заранее созданные потоки, берущие задачи из очереди. Задачи добавляются быстро, выполняются параллельно. Оптимальный размер = количество ядер. В Unreal Engine это Task Graph System. Стандарт для Job Systems в играх.",
                "code": "class ThreadPool {\n    vector<thread> workers;\n    queue<function<void()>> tasks;\n    mutex mtx;\n    condition_variable cv;\n    bool stop = false;\n    \npublic:\n    ThreadPool(int numThreads) {\n        for (int i = 0; i < numThreads; i++) {\n            workers.emplace_back([this] {\n                while (true) {\n                    function<void()> task;\n                    {\n                        unique_lock lock(mtx);\n                        cv.wait(lock, [this]{\n                            return stop || !tasks.empty();\n                        });\n                        if (stop) return;\n                        task = move(tasks.front());\n                        tasks.pop();\n                    }\n                    task();\n                }\n            });\n        }\n    }\n    \n    void enqueue(function<void()> task) {\n        {\n            lock_guard lock(mtx);\n            tasks.push(move(task));\n        }\n        cv.notify_one();\n    }\n};"
            }
        ]
    }
]